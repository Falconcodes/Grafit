////////////////////////////////////////////////////////////////////
// Для одного полупериода 7-14-25-50
//Для двух 7-12-13-15
///////////////////////////////////////////////////////////////////

//Библиотеки
#include <mega8.h>
#include <delay.h>

//Параметры 1 этапа
#define MIN_PWM_1 10 //процент от максимально допустимой мощности при данном включении, до которого будет увеличиваться мощность
#define MAX_PWM_1 14 //процент от максимальной мощности, до которого уменьшится мощность
#define PAUSE_1 500 //пауза после первого этапа (число периодов сети, 50 периодов = 1сек)
//Параметры 2 этапа
#define MIN_PWM_2 15
#define MAX_PWM_2 50
#define PAUSE_2 500

//Общие параметры
#define CHANGE_SPEED 1 //скорость изменения ШИМ, % в секунду, максимум 30
#define HPDELAY 158 //задержка, соответствующая полупериоду (при такой задержке мощность = 0)

//Названия ножек. ВАЖНО! при смене ножек, надо ниже сразу после "void main(void)" поправить DDRX.X на новые
#define LED PORTD.7
#define START PINB.5
#define FINISH PORTB.4
#define DROP PINB.6  //падение на тиристоре при открытых реле. 1 значит есть стержень, 0 значит крокодилы пусты.
#define KOLPAK PINB.7
#define VOLTAGE PORTD.0
#define TIR_OUT PORTC.0
#define LAMP PORTC.2 //лампа на корпусе - горит когда колпак одет (не забываем править DDRx)
#define LOCK_OFF PORTC.5 //электромагнитный замок дверцы

//Объявляем переменные: delay - счетчик переполнений таймера, delay_on - фазовая задержка открывания тиристора, 
//delay_min - минимальная задержка от начала периода до открывания, установленная для данного этапа, count - счетчик периодов, count_max - предел счета периодов
unsigned int count, count_max, i;
unsigned char delay=0, delay_on, delay_min_1, delay_min_2, wait=1, led_t=0, again=0;
signed char busy;

interrupt [TIM0_OVF] void timer0_overflow(void) {delay++;}     //Прерывание по переполнению  таймера - для отсчета задержки включения тиристора

interrupt [EXT_INT0] void ext_int0_isr(void) {       //Прерывание по началу полупериода сети - для начала отсчета задержки
TCNT0=0; //обнуляем счетный регистр
TIMSK=1;  //разрешаем прерывать таймером
count++;  //считаем пройденные периоды
led_t++;  //переменная для отсчета времени включения-выключения светодиода
  if (led_t==2) LED=0;
  if (led_t==10) {
  LED=1; 
  led_t=0; 
  } 
}

//функция пересчета заданного пользователем PWM в длительность задержки открывания тиристора
 int pwm_to_delay(int pwm) {
 return (int)(HPDELAY-HPDELAY*pwm/100)+1;
 }      
 
 //главная функция для каждого этапа нагрева, плавное нарастание мощности от PWM_MIN_X до PWM_MAX_X со скоростью CHANGE_SPEED, использует прерывания по INT0 и TC0
 void pwm(int delay_min, int pause); 

void main(void)
{#asm ("sei");     
 DDRB.4=DDRC.0=DDRC.2=DDRC.5=DDRD.0=DDRD.7=1; //выходы
 LED=1;  //светодиод выключен (идет на Vcc, а не землю - потому инверсия)
 TIR_OUT=FINISH=VOLTAGE=LAMP=0;  //все остальное тоже выключено
 
 DDRB.5=DDRB.6=DDRB.7=DDRD.2=0; //входы
 PORTB.5=PORTB.6=PORTD.2=0; //подтяжка к земле
 PORTB.7=LOCK_OFF=1; //подтяжка к Vcc
 
 while(1) { //основной программный цикл

 BEGIN: ; // возвращаемся сюда, если на момент старта в крокодилах не оказалось стержня

 while (!START); //ждем, когда на входе Старт появится высокий уровень, до тех пор стоим на месте. Если Старт уже был включен - проходим мимо

 LOCK_OFF=0; //даем напряжение на замок

 //ОЖИДАНИЕ СТАРТА
 //До подачи сигнала Старт крутимся в этом цикле, моргаем светодиодом редко и ждем сигнала. Флаг ожидания - wait

  while(wait) {
   while(KOLPAK){     //если колпак открыт - крутимся в этом цикле, пока не закроют, мигаем светодиодом часто
             LAMP=0; 
             LED=0;
             delay_ms(50);
             LED=1;
             delay_ms(50);
             
   }
  LED=0; //зажигаем светодиод на плате
  LAMP=1;  //и лампу на корпусе

   for (i=1;i<1000; i++) {
   delay_us(50);
   if  (START&(!KOLPAK)) wait=0;  // Если дан сигнал старта при неоткрытом колпаке, флаг ожидания сбрасываем для выхода из цикла ожидания
   if (KOLPAK) LAMP=0;
   }

   LED=1; 
   for (i=1;i<10000; i++) {
   delay_us(50);
   if  (START&(!KOLPAK)) wait=0;  // Если дан сигнал старта при неоткрытом колпаке, флаг ожидания сбрасываем для выхода из цикла ожидания
   if (KOLPAK) LAMP=0;
   }
  }


 AGAIN: ; //попадаем сюда, если колпак был снят и одет обратно в течение нагрева. Начинаем процесс сначала...
 again=0;  // сбрасываем флаг возврата
 LAMP=1;

 MCUCR=0b00000011;     //режим работы внешних прерываний: через Int0 по нарастающему фронту
 GICR|=0;       //внешние прерывания пока запрещены

 TCCR0|=0b00000001;  //делитель частоты = 1
 SREG|=0b10000000;  //разрешаем общие прерывания
 TIMSK|=0b00000000;  //запрещаем прерывания по таймеру
     
 delay_min_1=pwm_to_delay(MAX_PWM_1);  //время минимальной задержки рассчитывается исходя из максимального желаемого PWM
 delay_min_2=pwm_to_delay(MAX_PWM_2); 
 count_max=(int)(30/CHANGE_SPEED);

 VOLTAGE=1;    //включаем главные реле нагрузки

 delay_ms(1000); //устаканиваемся

 // проверка наличия стержня - по падению напряжения на закрытом тиристоре. Если DROP=1, падение есть и стержень присутствует.
   if (!DROP) {
    VOLTAGE=0; // отключаем главные реле
    LOCK_OFF=1; //обесточиваем замок дверцы
    while (!KOLPAK){   // крутимся тут, пока колпак закрыт, т.к. с закрытым не смогут поставить стержень. Моргаем быстро светодиодом. 
        LED=0;
        delay_ms(50);
        LED=1;
        delay_ms(50);
    }; 
    wait=1; // флаг ожидания снова установлен
    delay_ms(2000); //даем время дверце открыться после обесточивания замка
    goto BEGIN; // если колпак сняли, идем в начало, где ожидаем одевания колпака и сигнала "старт".
   }

 //ПЕРВЫЙ ПЕРИОД - ОБЖИГ ПАРАФИНА
 delay_on=pwm_to_delay(MIN_PWM_1);
 busy=-1;  // 2 чтобы при декременте не стал 0, как во втором периоде, где busy=1. декремент делается, если графит перегорел. На первом этапе это не происходит, спасаем от глюков с неконтактом.
 GICR|=0b01000000;     //разрешаем внешние прерывания через Int0 
    while(busy) pwm(delay_min_1, PAUSE_1);     //(int delay_min, int pause)
 if (again) goto AGAIN;
  
   //ВТОРОЙ ПЕРИОД - ПЛАВКА
   delay_on=pwm_to_delay(MIN_PWM_2);
   busy=1;
   GICR|=0b01000000;     //разрешаем внешние прерывания через Int0   
   while(busy) pwm(delay_min_2, PAUSE_2);
   if (again) goto AGAIN; 
   
   //Финальные процедуры
   GICR=0;  //запрещаем внешнее прерывание
   TIMSK=0; //запрет прерывания по ТС0
    delay_ms(500);
   VOLTAGE=0; //отключаем главное реле нагрузки
   delay_ms(500);
   FINISH=1;   //включаем реле финиша
   delay_ms(1000);
   FINISH=0;  
   delay_ms(60000); //открываем замок после минуты ожидания - чтобы крокодилы могли остыть
   LOCK_OFF=1; 
   while (START); //ожидаем сброса сигнала START, который оставался на протяжении всего процесса плавки, после чего будем ожидать нового сигнала START
   delay_ms(1000);
   wait=1; //возвращаемся в начало основного программного цикла, и снова ожидаем старта  
 }
}

////////////////////////////////////
//Окончание тела программы//
//далее описание функций//////////
///////////////////////////////

 void pwm(int delay_min, int pause) {   
        
    if (delay==delay_on) {  //после определенного количества переполнений таймера (= паузы после начала полупериода), включаем тиристор (ниже)
      GICR=0;  //запрещаем внешнее прерывание, чтобы в моменты переключения тиристора не было ложных срабатываний
      TIMSK=0; //запрет прерывания по ТС0 (разрешение будет в начале следующего полупериода - после внешнего прерывания)
      delay=0; //обнуляем счетчик прерываний по переполнениям таймера, т.к. дождались момента включения тиристора
      TIR_OUT=1;  //открываем тиристор  
      delay_us(100); //задержка на высоком уровне
      TIR_OUT=0;   //закрываем тиристор (на самом деле, закроется когда кончится полупериод)
      delay_us(200);
      GICR|=0b01000000;     //разрешаем внешние прерывания через Int0           
      if (!DROP) busy--;   //если стержень перегорел, декрементируем флаг занятости. Во втором этапе он изначально 1, то есть сброс после перегорания. В первом не 1, чтобы защититься от неконтакта
      if (busy==-120)  {
        busy=-1;
        }
      }
      
    if ((count==count_max)&(delay_on!=delay_min+1)) {  //количество пройденных периодов до изменения ШИМ  (если 1, то изменение шим на 10% будет за 0,333 сек)
      delay_on--;   //уменьшаем время задержки = увел. ШИМ на одну ступень (из 155 ступеней всего), по достижению мин. задержки - перестаем уменьшать
      count=0;  //сброс счетчика периодов
    } 
    
    if ((count==(count_max+pause))&(delay_on==delay_min+1)) {
     count=0;
     busy=0;    //после выжидания паузы на определенной мощности, сбрасываем флаг занятости и переходим на следующий этап нагрева
    }   
   
   if (KOLPAK) {    //делаем проверку, что колпак не открыт, иначе уходим в бесконечный цикл
         GICR=0;  //запрещаем внешнее прерывание
         TIMSK=0; //запрет прерывания по ТС0
         TCNT0=0; //обнуляем счетный регистр
         TIR_OUT=0;
         LAMP=0; //гаснет лампа на корпусе
         delay_ms(1);
         VOLTAGE=0;
    while(KOLPAK){
           LED=0;
           delay_ms(50);
           LED=1;
           delay_ms(50);
          }
     again=1; //если колпак вернули на место, устанавливаем флаг повторения с нуля. Флаг будет обработан и сброшен после выхода из функции
     count=0;
     delay=0;
     busy=0;   //сбрасываем флаг занятости, чтобы выйти из функции   
     delay_ms(200);
   } 
 }
 
